<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cli | Ruslan Osipov]]></title>
  <link href="http://www.rosipov.com/blog/categories/cli/atom.xml" rel="self"/>
  <link href="http://www.rosipov.com/"/>
  <updated>2020-09-20T18:32:27+00:00</updated>
  <id>http://www.rosipov.com/</id>
  <author>
    <name><![CDATA[Ruslan Osipov]]></name>
    <email><![CDATA[ruslan@rosipov.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vortex Core 40% keyboard]]></title>
    <link href="http://www.rosipov.com/blog/vortex-core-keyboard/"/>
    <updated>2020-09-13T17:00:00+00:00</updated>
    <id>http://www.rosipov.com/blog/vortex-core-keyboard</id>
    <content type="html"><![CDATA[<p><em>This review is written entirely using Vortex Core, in Markdown, and using Vim.</em></p>

<p>Earlier this week I purchased <a href="https://amzn.to/3ivzMCK">Vortex Core</a> - a 40% keyboard from a Taiwanese company Vortex, makers of the ever popular <a href="https://mechanicalkeyboards.com/shop/index.php?l=product_detail&amp;p=3633">Pok3r</a> keyboard (which I happen to use as my daily driver). This is a keyboard with only 47 keys: it drops the numpad (what&rsquo;s called 80%), function row (now we&rsquo;re down to 60%), and the dedicated number row (bringing us to the 40% keyboard realm).</p>

<p>Words don&rsquo;t do justice to how small a 40% keyboard is. So here is a picture of Vortex Core next to Pok3r, which is an already a small keyboard.</p>

<p><img src="/images/posts/vortex-core-and-pok3r.jpg" title="A picture of Vortex Core 40% keyboard next to a Pok3r 60% keyboard." ></p>

<p>At around a <a href="https://amzn.to/3ivzMCK">$100 on Amazon</a> it&rsquo;s one of the cheaper 40% options, but Vortex did not skimp on quality. The case is sturdy, is made of beautiful anodized aluminum, and has some weight to it. The keycaps this keyboard comes with feel fantastic (including slight dips on <code>F</code> and <code>J</code> keys), and I`m a huge fan of the look.</p>

<p>I hooked it up to my Microsoft Surface Go as a toy more than anything else. And now I think I may have discovered the perfect writing machine! Small form factor of the keyboard really compliments the already small Surface Go screen, and there&rsquo;s just enough screen real estate to comfortably write and edit text.</p>

<p><img src="/images/posts/vortex-core-and-surface-go.jpg" title="A picture of Vortex Core 40% keyboard plugged into Microsoft Surface Go screen." ></p>

<p>I&rsquo;ve used Vortex Core on and off for the past few days, and I feel like I have a solid feel for it. Let&rsquo;s dig in!</p>

<h2>What&rsquo;s different about it?</h2>

<p>First, the keycap size and distance between keys are standard: it&rsquo;s a standard staggered layout most people are used to. This means that when typing words, there is no noticeable speed drop. In fact I find myself typing a tiny bit faster using this keyboard than my daily driver - but that could just be my enthusiasm shining through. I hover at around 80 words per minute on both keyboards.</p>

<p>That is until it&rsquo;s time to type &ldquo;you&rsquo;re&rdquo;, or use any punctuation outside of the <code>:;,.&lt;&gt;</code> symbols. That&rsquo;s right, the normally easily accessible apostrophe is hidden under the function layer (<code>Fn1 + b</code>), and so is the question mark (<code>Fn1 + Shift + Tab</code>). <code>-</code>, <code>=</code>, <code>/</code>, <code>\</code>, <code>[</code>, and <code>]</code> are gone too, and I&rsquo;ll cover those in due time.</p>

<p>On a first day this immediately dropped my typing speed to around 50 words per minute, as it&rsquo;s completely unintuitive at first! In fact, I just now stopped hitting <code>Enter</code> every time I tried to place an apostrophe! But only after a few hours of sparingly using Vortex Core I&rsquo;m up to 65 WPM, and it feels like I would regain my regular typing speed within a week.</p>

<p>Despite what you might think, it&rsquo;s relatively easy to get used to odd key placement like this.</p>

<p>Keys have 4 layers (not to be confused with programming layers), and that&rsquo;s how the numbers, symbols, and some of the more rarely used keys are accessed. For example, here&rsquo;s what the key <code>L</code> contains:</p>

<ul>
<li>Default layer (no modifiers): <code>L</code></li>
<li><code>Fn1</code> layer: <code>0</code></li>
<li><code>Fn1 + Shift</code> layer: <code>)</code></li>
<li><code>Fn</code> layer: <code>right arrow key</code></li>
</ul>


<p>The good news is that unlike many 40% keyboards on the market (and it&rsquo;s a rather esoteric market), Vortex Core has key inscriptions for each layer. Something like <a href="https://mechanicalkeyboards.com/shop/index.php?l=product_detail&amp;p=3633https://olkb.com/collections/planck">Planck</a> would require you to print out layout cheatsheets while you get used to the function layers.</p>

<p><img src="/images/posts/vortex-core-left-half.jpg" title="Left side of the Vortex Core keyboard, demonstrating numbers and special characters." ></p>

<p>As I continue attempting to type, numbers always take me by surprise: the whole number row is a function layer on top of the home row (where your fingers normally rest). After initially hitting the empty air when attempting to type numbers, I began to get used to using the home row instead.</p>

<p>The placement mimics the order the keys would be in on the number row (<code>1234567890-=</code>), but <code>1</code> is placed on the <code>Tab</code> key, while <code>=</code> is on the <code>Enter</code>. While I was able to find the numbers relatively easily due to similar placement, I would often be off-by-one due to row starting on a <code>Tab</code> key.</p>

<p>Things get a lot more complicated when it comes to special symbols. These are already normally gated behind a <code>Shift</code>-press on a regular keyboard, and Vortex Core requires some Emacs-level gymnastics! E.g. you need to press <code>Fn1 + Shift + F</code> to conjure <code>%</code>.</p>

<p>Such complex keypresses are beyond counter-intuitive at first. Yet after a few hours, I began to get used to some of the more frequently used keys: <code>!</code> is <code>Fn1 + Shift + Tab</code>, <code>-</code> is <code>Fn1 + Shift + 1</code>, <code>$</code> (end of line in Vim) is <code>Fn1 + Shift + D</code>, and so on. Combining symbols quickly becomes problematic.</p>

<p>It&rsquo;s fairly easy to get used to inserting a lone symbol here and there, but the problems start when having to combine multiple symbols at once. E.g. writing an expression like <code>'Fn1 + Shift + D' = '$'</code> above involves the following keypresses: <code>&lt;Fn1&gt;&lt;Esc&gt; F N &lt;Fn1&gt;&lt;Tab&gt; &lt;Fn1&gt;&lt;Shift&gt;&lt;Enter&gt; S H I F T &lt;Fn1&gt;&lt;Shift&gt;&lt;Enter&gt; D &lt;Fn1&gt;&lt;Esc&gt; &lt;Fn1&gt;&lt;Enter&gt; &lt;Fn1&gt;&lt;Esc&gt; &lt;Fn1&gt;&lt;Shift&gt;D &lt;Fn1&gt;&lt;Esc&gt;</code>. Could you image how long it took me to write that up?</p>

<p><img class="/images/posts/vortex-core-right-half.jpg Right side of the Vortex Core keyboard, demonstrating special characters placed on" src="<code>bnm,.</code>&#8221; title=&#8221;keys.&#8221; ></p>

<p>The most difficult part of getting used to the keyboard is the fact that a few keys on the right side are chopped off: <code>'/[]\</code> are placed in the bottom right of the keyboard, to <code>bnm,.</code> keys. While the rest of the layout attempts to mimic the existing convention and only shifting the rows down, the aforementioned keys are placed arbitrarily (as there&rsquo;s no logical way to place them otherwise).</p>

<p>This probably won&rsquo;t worry you if you don&rsquo;t write a lot of code or math, but I do, and it`s muscle memory I&rsquo;ll have to develop.</p>

<p>There are dedicated <code>Del</code> and <code>Backspace</code> keys, which is a bit of an odd choice, likely influenced by needing somewhere to place the <code>F12</code> key - function row is right above the home row, and is hidden behind the <code>Fn1</code> layer.</p>

<p>Spacebar is split into two (for ease of finding keycaps I hear), and it doesn&rsquo;t affect me whatsoever. I mostly hit spacebar with my left thumb and it&rsquo;s convenient.</p>

<p><code>Tab</code> is placed where the <code>Caps Lock</code> is, which feels like a good choice. After accidentally hitting <code>Esc</code> a few times, I got used to the position. Do make sure to get <a href="http://www.vortexgear.tw/vortex3.asp">latest firmware</a> for your Vortex Core - I believe earlier firmware versions hides Tab behind a function layer, defaulting the key to <code>Caps Lock</code> (although my keycaps reflected the updated firmware).</p>

<p>So I&rsquo;d say the numbers and the function row take the least amount of time to get used to. It&rsquo;s the special characters that take time.</p>

<h2>Can you use it with Vim?</h2>

<p>I&rsquo;m a huge fan of Vim, and I even wrote <a href="https://amzn.to/3htsTjK">a book</a> on the subject. In fact, I&rsquo;m writing this very review in Vim.</p>

<p>And I must say, it&rsquo;s difficult. My productivity took a hit. I use curly braces to move between paragraphs, I regularly search with <code>/</code>, <code>?</code>, and <code>*</code>, move within a line with <code>_</code> and <code>$</code>, and use numbers in my commands like <code>c2w</code> (change two words) as well as other special characters, e.g. <code>da"</code> (delete around double quotes).</p>

<p>The most difficult combination being spelling correction: <code>z=</code> followed by a number to select the correct spelling. I consistency break the flow by having to press <code>Z &lt;Fn1&gt;&lt;Enter&gt; &lt;Fn1&gt;&lt;Tab&gt;</code> or something similar to quickly fix a misspelling.</p>

<p>My Vim productivity certainly took a massive hit. Yet, after a few days it&rsquo;s starting to slowly climb back up, and I find myself remembering the right key combinations as the muscle memory kicks in.</p>

<p>I assume my Vim experience translates well into programming. Even though I write code for a living, I haven&rsquo;t used Vortex Core to crank out code.</p>

<h2>Speaking of programming</h2>

<p>The whole keyboard is fully programmable (as long as you update it to the <a href="http://www.vortexgear.tw/vortex3.asp">latest firmware</a>).</p>

<p>It&rsquo;s an easy process - a <a href="http://www.vortexgear.tw/vortex3.asp">three page manual</a> covers everything that&rsquo;s needed like using different keyboard layers or remapping regular and function keys.</p>

<p>The manual also mentions using right <code>Win</code>, <code>Pn</code>, <code>Ctrl</code>, and <code>Shift</code> keys as arrow keys by hitting left <code>Win</code>, left <code>Alt</code>, and right spacebar. Vortex keyboards nowadays always come with this feature, but due to small form factor of the keys (especially Shift), impromptu arrow keys on Vortex Core are nearly indistinguishable from individual arrow keys.</p>

<p>Remapping is helpful, since I&rsquo;m used to having <code>Ctrl</code> where <code>Caps Lock</code> is (even though this means I have to hide Tab behind a function layer), or using <code>hjkl</code> as arrow keys (as opposed to the default <code>ijkl</code>).</p>

<p>It took me only a few minutes to adjust the keyboard to my needs, but I imagine I will come back for tweaks - I&rsquo;m not so sure if I&rsquo;ll be able to get used to special symbols hidden behind <code>Fn1</code> + <code>Shift</code> + key layer. Regularly pressing three keys at the time (with two of these keys being on the edge of the keyboard) feels unnatural and inconvenient right now. But I&rsquo;m only a few hours in, and stenographers manager to do it.</p>

<h2>Living in the command line</h2>

<p>The absence of certain special characters is especially felt when using the command line. Not having a forward slash available with a single keypress makes typing paths more difficult. I also use <code>Ctrl + \</code> as a modifier key for tmux, and as you could imagine it&rsquo;s just as problematic.</p>

<p>Despite so many difficulties, I&rsquo;m loving my time with Vortex Core! To be honest with myself, I don&rsquo;t buy new keyboards to be productive, or increase my typing speed. I buy them because they look great and are fun to type on. And Vortex Core looks fantastic, and being able to cover most of the keyboard with both hands is amazing.</p>

<p>There&rsquo;s just something special about having such a small board under my fingertips.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Drive on Linux with rclone]]></title>
    <link href="http://www.rosipov.com/blog/google-drive-on-linux-with-rclone/"/>
    <updated>2019-06-23T07:00:00+00:00</updated>
    <id>http://www.rosipov.com/blog/google-drive-on-linux-with-rclone</id>
    <content type="html"><![CDATA[<p>Recently Dropbox hit me with the <a href="https://help.dropbox.com/accounts-billing/settings-sign-in/computer-limit">following announcement</a>:</p>

<blockquote><p>Basic users have a three device limit as of March 2019.</p></blockquote>

<p>Being the &ldquo;basic&rdquo; user, and relying on Dropbox across multiple machines, I got unreasonably upset (&ldquo;How dare you deny me free access to your service?!&rdquo;) and started looking for a replacement.</p>

<p>I already store quite a lot of things in Google Drive, so it seemed like a no brainer: I migrated all my machines to Google Drive overnight. There was but only one problem: Google Drive has official clients for Windows and Mac, but there&rsquo;s nothing when it comes to Linux.</p>

<p>I found the Internets to be surprisingly sparse on the subject, and I had to try multiple solutions and spent more time than I&rsquo;d like researching options.</p>

<p>The best solution for me turned out to be <code>rclone</code>, which mounts Google Drive as a directory. It requires <code>rclone</code> service to be constantly running in order to access the data, which is a plus for me - I&rsquo;ve accidentally killed Dropbox daemon in the past and had to deal with conflicts in my files.</p>

<p>Install <code>rclone</code> (<a href="https://rclone.org/install/">instructions</a>):</p>

<pre><code>curl https://rclone.org/install.sh | sudo bash
</code></pre>

<p>From then on, <a href="https://rclone.org/drive/">rclone website some documentation</a> when it comes to the setup. I found it somewhat difficult to parse, so here it is paraphrased:</p>

<p>Launch <code>rclone config</code> and follow the prompts:</p>

<ul>
<li><code>n) New remote</code></li>
<li><code>name&gt; remote</code></li>
<li>Type of storage to configure: <code>Google Drive</code></li>
<li>Leave <code>client_id&gt;</code> and <code>client_secret&gt;</code> blank</li>
<li>Scope: <code>1 \ Full access to all files</code></li>
<li>Leave <code>root_folder_id&gt;</code> and <code>service_account_file&gt;</code> blank</li>
<li>Use auto config? <code>y</code></li>
<li>Configure this as a team drive? <code>n</code></li>
<li>Is this OK? <code>y</code></li>
</ul>


<p>From here on, you can interact with your Google Drive by running <code>rclone</code> commands (e.g. <code>rclone ls remote:</code> to list top level files). But I am more interested in a continuous running service and <code>mount</code> is what I need:</p>

<pre><code>rclone mount remote: $HOME/Drive
</code></pre>

<p>Now my Google Drive is accessible at <code>~/Drive</code>. All that&rsquo;s left is to make sure the directory is mounted on startup.</p>

<p>For Ubuntu/Debian, I added the following line to <code>/etc/rc.local</code> (before <code>exit 0</code>, and you need <code>sudo</code> access to edit the file):</p>

<pre><code>rclone mount remote: $HOME/Drive
</code></pre>

<p>For my i3 setup, all I needed was to add the following to <code>~/.config/i3/config</code>:</p>

<pre><code>exec rclone mount remote: $HOME/Drive
</code></pre>

<p>It&rsquo;s been working without an issue for a couple of weeks now - and my migration from Dropbox turned out to be somewhat painless and quick.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desktop notifications from Chrome Secure Shell]]></title>
    <link href="http://www.rosipov.com/blog/desktop-notifications-from-chrome-secure-shell/"/>
    <updated>2017-08-04T17:33:16+00:00</updated>
    <id>http://www.rosipov.com/blog/desktop-notifications-from-chrome-secure-shell</id>
    <content type="html"><![CDATA[<p>For the past year or two I&rsquo;ve been working in the cloud. I use Chrome <a href="https://chrome.google.com/webstore/detail/secure-shell/pnhechapfaindjhompbnflcldabbghjo?hl=en">Secure Shell</a> to connect to my machines, and it works rather well. In fact, I moved away from my work Linux/Mac laptops towards an <a href="http://amzn.to/2hv68Ck">HP Chromebook</a>, which fullfilled both requirements I had: a browser and a terminal. One thing I missed about a Linux machine though is lack of <code>notify-send</code>-like functionality, especially when working with long-running builds.</p>

<p>Yesterday I pinged hterm team for assistance with this matter, and turns out recent release of Secure Shell supports Chrome desktop notifications! Furthermore, two amazing engineers (thanks Andrew and Mike!) crafted an <a href="https://chromium-review.googlesource.com/c/601549/3/hterm/etc/hterm-notify.sh">hterm-notify</a> script, which propagates notifications to Chrome, and by extent to desktop!</p>

<p>I made a few tiny changes, mainly since I don&rsquo;t use <code>screen</code>, and tmux sets my <code>$TERM</code> to <code>screen-256color</code> for some reason:</p>

<pre><code>#!/bin/sh
# Copyright 2017 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Write an error message and exit.
# Usage: &lt;message&gt;
die() {
  echo "ERROR: $*"
  exit 1
}

# Send a notification.
# Usage: [title] [body]
notify() {
  local title="${1-}" body="${2-}"

  case ${TERM-} in
  screen*)  # This one's really tmux
    printf '\ePtmux;\e\e]777;notify;%s;%s\a\e\\' "${title}" "${body}"
    ;;
  *)        # This one's plain hterm
    printf '\e]777;notify;%s;%s\a' "${title}" "${body}"
    ;;
  esac
}

# Write tool usage and exit.
# Usage: [error message]
usage() {
  if [ $# -gt 0 ]; then
    exec 1&gt;&amp;2
  fi
  cat &lt;&lt;EOF
Usage: hterm-notify [options] &lt;title&gt; [body]

Send a notification to hterm.

Notes:
- The title should not have a semi-colon in it.
- Neither field should have escape sequences in them.
  Best to stick to plain text.
EOF

  if [ $# -gt 0 ]; then
    echo
    die "$@"
  else
    exit 0
  fi
}

main() {
  set -e

  while [ $# -gt 0 ]; do
    case $1 in
    -h|--help)
      usage
      ;;
    -*)
      usage "Unknown option: $1"
      ;;
    *)
      break
      ;;
    esac
  done

  if [ $# -eq 0 ]; then
    die "Missing message to send"
  fi
  if [ $# -gt 2 ]; then
    usage "Too many arguments"
  fi

  notify "$@"
}
main "$@"
</code></pre>

<p>Throwing this in as <code>~/bin/notify</code> (not forgetting to <code>chmod +x</code> and having <code>~/bin</code> in the <code>$PATH</code>) I can get a notification when a particular long running command is complete:</p>

<pre><code>sleep 30 &amp;&amp; notify Hooray "The sleep's done!"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Browsing MSSQL and Vertica from CLI]]></title>
    <link href="http://www.rosipov.com/blog/browsing-mssql-and-vertica-from-cli/"/>
    <updated>2016-09-28T18:51:31+00:00</updated>
    <id>http://www.rosipov.com/blog/browsing-mssql-and-vertica-from-cli</id>
    <content type="html"><![CDATA[<p>Notes to make sure I don&rsquo;t forget how to do this in the future. First, install
<code>mssql</code> and <code>vcli</code> tools:</p>

<pre><code>npm install -g sql-cli
pip install vcli
</code></pre>

<p>Encrypt desired database account passwords:</p>

<pre><code>mkdir -p ~/.passwd
echo '$PASSWORD' | gpg --use-agent -e &gt; ~/.passwd/$DB_ACCOUNT.gpg
</code></pre>

<p>Set up a set of aliases with the desired level of flexibility in <code>~/.bashrc</code> to
avoid typing too much:</p>

<pre><code>function _sql-helper-command {
  host=$1
  user=$2
  password=$3
  db=$4
  opt_query_file=$5

  if [ -z $opt_query_file ]; then
    mssql -s $host -u $user -p $password -d $db
  else
    mssql -s $host -u $user -p $password -d $db -q "`cat $opt_query_file`"
  fi
}

function _vsql-helper-command {
  host=$1
  user=$2
  password=$3

  vcli -h $host -U $user -w $password
}

# Usage: `sql` for interactive mode, `sql filename.sql` to execute a file.
function sql {
  opt_query_file=$1

  host='$SOME_HOST'
  user='$SOME_USER'
  password=`gpg --use-agent --quiet --batch -d ~/.passwd/$SOME_FILENAME.gpg`
  db='$SOME_DB'

  _sql-helper-command $host $user $password $db $opt_query_file
}

# Usage: `vsql $VERTICA_HOST`
function vsql {
  host=$1
  user=`whoami`
  password=`gpg --use-agent --quiet --batch -d ~/.passwd/$SOME_FILENAME.gpg`

  _vsql-helper-command $host $user $password
}
</code></pre>

<p>Replace <code>$SOME_USER</code>, <code>$SOME_HOST</code>, <code>$SOME_DB</code>, <code>$SOME_FILENAME</code> above with
specific user, host, DB, and filenames respectively. I usually make a bunch of
aliases for different environments/machines I use: <code>sql-prod</code>, <code>sql-dev</code>,
<code>sql-local</code> or <code>vsql-host1</code>, <code>vsql-host2</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Profiling slow bashrc]]></title>
    <link href="http://www.rosipov.com/blog/profiling-slow-bashrc/"/>
    <updated>2015-07-15T17:07:53+00:00</updated>
    <id>http://www.rosipov.com/blog/profiling-slow-bashrc</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve recently noticed that it takes a long time for my bash to load. I&rsquo;ve found
<a href="http://stackoverflow.com/a/5015179/2578489">following StackOverflow answer</a> to be useful, and I based my solution to find a
startup time hog in my <code>~/.bashrc</code> upon it.</p>

<p>First off, add following few lines to your <code>/etc/bash.bashrc</code>,
<code>~/.bash_profile</code>, or wherever you&rsquo;d like to begin tracing the script:</p>

<pre><code>PS4='+ $(date "+%s.%N")\011 '
exec 3&gt;&amp;2 2&gt;/tmp/bashstart.$$.log
set -x
</code></pre>

<p>And add following few lines where you want to stop the trace:</p>

<pre><code>set +x
exec 2&gt;&amp;3 3&gt;&amp;-
</code></pre>

<p>Now start your bash session (you can simply open a new terminal Window for
that). The above will create <code>/tmp/bashstart.&lt;PID&gt;.log</code>. To analyze it, I wrote
a little Python script:</p>

<pre><code>import argparse
import heapq

parser = argparse.ArgumentParser(description='Analyze bashstart log for speed.')
parser.add_argument('filename', help='often /tmp/bashstart.&lt;PID&gt;.log')
parser.add_argument('-n', default=20, help='number of results to show')
args = parser.parse_args()
filename, n = args.filename, int(args.n)

with open(filename, 'r') as f:
    q = []
    prev_time = None
    for line in f.readlines():
        line = line.split()
        if '+' not in line[0] or len(line) &lt; 3:
            continue
        text = ' '.join(line[2:])
        seconds, nanoseconds = line[1].split('.')
        time = int(nanoseconds)
        diff = time - prev_time if prev_time is not None else 0
        prev_time = time
        heapq.heappush(q, (diff, text))

for diff, text in heapq.nlargest(n, q):
    print float(diff) / 1000000000, 's:', text
</code></pre>

<p>Save it as <code>bashprofile.py</code>, and run it as follows (replace file name with an
appropriate):</p>

<pre><code>python bashprofile.py /tmp/bashstart.2831.log -n 20
0.050056909 s: _powerline_init_tmux_support
0.045323022 s: _powerline_setup_prompt
0.044722024 s: _powerline_setup_prompt
0.044423727 s: '[' -f /usr/local/google/home/ruslano/.local/lib/python2.7/site-packages/powerline/bindings/bash/powerline.sh ']'
0.044364097 s: '[' -f /usr/local/google/home/ruslano/.local/lib/python2.7/site-packages/powerline/bindings/bash/powerline.sh ']'
0.044137159 s: _powerline_init_tmux_support
0.015839574 s: __shell_name=bash
0.010850276 s: command which which
0.010105462 s: PS2='\[\]  \[\] \[\]'
0.010000598 s: PS3=' Select variant  '
0.009837956 s: complete -F _svn -o default -X '@(*/.svn|*/.svn/|.svn|.svn/)' svn
0.009767517 s: PS2='\[\]  \[\] \[\]'
0.0095753 s: PS3=' Select variant  '
0.007915565 s: other_utils=(ant automake autoreconf libtoolize make mount patch readlink)
0.00771205 s: for script in version functions/selector cd functions/cli cli override_gem
0.007008299 s: for gnu_util in '"${gnu_utils[@]}"'
0.00693653 s: complete -F _crow crow
0.006803049 s: complete -F _svn -o default -X '@(*/.svn|*/.svn/|.svn|.svn/)' svn
0.006672906 s: for script in version functions/selector cd functions/cli cli override_gem
0.005912399 s: for entry in '${scripts[@]}'
</code></pre>

<p>In my example, <a href="https://github.com/powerline/powerline">Powerline</a> turned out to be a massive hog. Looks like I&rsquo;ll
have to troubleshoot the speed or plain disable it.</p>

<p>Don&rsquo;t forget to remove the lines you added to your bash configuration files
after you&rsquo;re done profiling.</p>
]]></content>
  </entry>
  
</feed>
